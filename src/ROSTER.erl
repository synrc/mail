%% Generated by the Erlang ASN.1 PER (aligned) compiler. Version: 5.0.8
%% Purpose: Encoding and decoding of the types in ROSTER.

-module('ROSTER').
-compile(nowarn_unused_vars).
-dialyzer(no_improper_lists).
-include("ROSTER.hrl").
-asn1_info([{vsn,'5.0.8'},
            {module,'ROSTER'},
            {options,[per,{i,"."}]}]).

-export([encoding_rule/0,maps/0,bit_string_format/0,
         legacy_erlang_types/0]).
-export(['dialyzer-suppressions'/1]).
-export([
enc_MUC/1,
enc_P2P/1,
enc_Ack/1,
enc_Bin/1,
enc_Typ/1,
enc_Adr/1,
enc_Msg/1
]).

-export([
dec_MUC/1,
dec_P2P/1,
dec_Ack/1,
dec_Bin/1,
dec_Typ/1,
dec_Adr/1,
dec_Msg/1
]).

-export([info/0]).

-export([encode/2,decode/2]).

encoding_rule() -> per.

maps() -> false.

bit_string_format() -> bitstring.

legacy_erlang_types() -> false.

encode(Type, Data) ->
try complete(encode_disp(Type, Data)) of
  Bytes ->
    {ok,Bytes}
  catch
    Class:Exception:Stk when Class =:= error; Class =:= exit ->
      case Exception of
        {error,{asn1,Reason}} ->
          {error,{asn1,{Reason,Stk}}};
        Reason ->
         {error,{asn1,{Reason,Stk}}}
      end
end.

decode(Type, Data) ->
try
   {Result,_Rest} = decode_disp(Type, Data),
   {ok,Result}
  catch
    Class:Exception:Stk when Class =:= error; Class =:= exit ->
      case Exception of
        {error,{asn1,Reason}} ->
          {error,{asn1,{Reason,Stk}}};
        Reason ->
         {error,{asn1,{Reason,Stk}}}
      end
end.

encode_disp('MUC', Data) -> enc_MUC(Data);
encode_disp('P2P', Data) -> enc_P2P(Data);
encode_disp('Ack', Data) -> enc_Ack(Data);
encode_disp('Bin', Data) -> enc_Bin(Data);
encode_disp('Typ', Data) -> enc_Typ(Data);
encode_disp('Adr', Data) -> enc_Adr(Data);
encode_disp('Msg', Data) -> enc_Msg(Data);
encode_disp(Type, _Data) -> exit({error,{asn1,{undefined_type,Type}}}).

decode_disp('MUC', Data) -> dec_MUC(Data);
decode_disp('P2P', Data) -> dec_P2P(Data);
decode_disp('Ack', Data) -> dec_Ack(Data);
decode_disp('Bin', Data) -> dec_Bin(Data);
decode_disp('Typ', Data) -> dec_Typ(Data);
decode_disp('Adr', Data) -> dec_Adr(Data);
decode_disp('Msg', Data) -> dec_Msg(Data);
decode_disp(Type, _Data) -> exit({error,{asn1,{undefined_type,Type}}}).

info() ->
   case ?MODULE:module_info(attributes) of
     Attributes when is_list(Attributes) ->
       case lists:keyfind(asn1_info, 1, Attributes) of
         {_,Info} when is_list(Info) ->
           Info;
         _ ->
           []
       end;
     _ ->
       []
   end.
enc_MUC(Val) ->
[align|begin
%% attribute name(1) with type OCTET STRING
Enc1@element = element(2, Val),
Enc2@len = byte_size(Enc1@element),
if Enc2@len < 128 ->
[Enc2@len|Enc1@element];
Enc2@len < 16384 ->
[<<2:2,Enc2@len:14>>|Enc1@element];
true ->
encode_fragmented(Enc1@element, 8)
end
end].


dec_MUC(Bytes) ->

%% attribute name(1) with type OCTET STRING
{Term1,Bytes1} = begin
V1@Pad3 = bit_size(Bytes) band 7,
{V1@V0,V1@Buf1} = case Bytes of
<<_:V1@Pad3,0:1,V1@V5:7,V1@V7:V1@V5/binary-unit:8,V1@Buf8/bitstring>> ->
{V1@V7,V1@Buf8};
<<_:V1@Pad3,1:1,0:1,V1@V6:14,V1@V8:V1@V6/binary-unit:8,V1@Buf9/bitstring>> ->
{V1@V8,V1@Buf9};
<<_:V1@Pad3,1:1,1:1,V1@V6:6,V1@Buf7/bitstring>> ->
{V1@V8,V1@Buf9}  = decode_fragmented(V1@V6, V1@Buf7, 8),
{V1@V8,V1@Buf9}
end,
V1@Conv10 = binary:copy(V1@V0),
{V1@Conv10,V1@Buf1}
end,
Res1 = {'MUC',Term1},
{Res1,Bytes1}.

enc_P2P(Val) ->
[align,
begin
%% attribute from(1) with type OCTET STRING
Enc1@element = element(2, Val),
Enc2@len = byte_size(Enc1@element),
if Enc2@len < 128 ->
[Enc2@len|Enc1@element];
Enc2@len < 16384 ->
[<<2:2,Enc2@len:14>>|Enc1@element];
true ->
encode_fragmented(Enc1@element, 8)
end
end|begin
%% attribute to(2) with type OCTET STRING
Enc3@element = element(3, Val),
Enc4@len = byte_size(Enc3@element),
if Enc4@len < 128 ->
[Enc4@len|Enc3@element];
Enc4@len < 16384 ->
[<<2:2,Enc4@len:14>>|Enc3@element];
true ->
encode_fragmented(Enc3@element, 8)
end
end].


dec_P2P(Bytes) ->

%% attribute from(1) with type OCTET STRING
{Term1,Bytes1} = begin
V1@Pad3 = bit_size(Bytes) band 7,
{V1@V0,V1@Buf1} = case Bytes of
<<_:V1@Pad3,0:1,V1@V5:7,V1@V7:V1@V5/binary-unit:8,V1@Buf8/bitstring>> ->
{V1@V7,V1@Buf8};
<<_:V1@Pad3,1:1,0:1,V1@V6:14,V1@V8:V1@V6/binary-unit:8,V1@Buf9/bitstring>> ->
{V1@V8,V1@Buf9};
<<_:V1@Pad3,1:1,1:1,V1@V6:6,V1@Buf7/bitstring>> ->
{V1@V8,V1@Buf9}  = decode_fragmented(V1@V6, V1@Buf7, 8),
{V1@V8,V1@Buf9}
end,
V1@Conv10 = binary:copy(V1@V0),
{V1@Conv10,V1@Buf1}
end,

%% attribute to(2) with type OCTET STRING
{Term2,Bytes2} = begin
{V2@V0,V2@Buf1} = case Bytes1 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end,
V2@Conv8 = binary:copy(V2@V0),
{V2@Conv8,V2@Buf1}
end,
Res1 = {'P2P',Term1,Term2},
{Res1,Bytes2}.

enc_Ack(Val) ->
[align,
begin
%% attribute id(1) with type INTEGER
Enc1@element = element(2, Val),
encode_unconstrained_number(Enc1@element)
end|begin
%% attribute table(2) with type OCTET STRING
Enc3@element = element(3, Val),
Enc4@len = byte_size(Enc3@element),
if Enc4@len < 128 ->
[Enc4@len|Enc3@element];
Enc4@len < 16384 ->
[<<2:2,Enc4@len:14>>|Enc3@element];
true ->
encode_fragmented(Enc3@element, 8)
end
end].


dec_Ack(Bytes) ->

%% attribute id(1) with type INTEGER
{Term1,Bytes1} = begin
V1@Pad3 = bit_size(Bytes) band 7,
{V1@V0,V1@Buf1} = case Bytes of
<<_:V1@Pad3,0:1,V1@V5:7,V1@Buf6/bitstring>> when V1@V5 =/= 0 ->
{V1@V5,V1@Buf6};
<<_:V1@Pad3,1:1,0:1,V1@V6:14,V1@Buf7/bitstring>> when V1@V6 =/= 0 ->
{V1@V6,V1@Buf7}
end,
<<V1@V8:V1@V0/signed-unit:8,V1@Buf9/bitstring>> = V1@Buf1,
{V1@V8,V1@Buf9}
end,

%% attribute table(2) with type OCTET STRING
{Term2,Bytes2} = begin
{V2@V0,V2@Buf1} = case Bytes1 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end,
V2@Conv8 = binary:copy(V2@V0),
{V2@Conv8,V2@Buf1}
end,
Res1 = {'Ack',Term1,Term2},
{Res1,Bytes2}.

enc_Bin(Val) ->
[align,
begin
%% attribute id(1) with type OCTET STRING
Enc1@element = element(2, Val),
Enc2@len = byte_size(Enc1@element),
if Enc2@len < 128 ->
[Enc2@len|Enc1@element];
Enc2@len < 16384 ->
[<<2:2,Enc2@len:14>>|Enc1@element];
true ->
encode_fragmented(Enc1@element, 8)
end
end,
begin
%% attribute mime(2) with type OCTET STRING
Enc3@element = element(3, Val),
Enc4@len = byte_size(Enc3@element),
if Enc4@len < 128 ->
[Enc4@len|Enc3@element];
Enc4@len < 16384 ->
[<<2:2,Enc4@len:14>>|Enc3@element];
true ->
encode_fragmented(Enc3@element, 8)
end
end|begin
%% attribute payload(3) with type OCTET STRING
Enc5@element = element(4, Val),
Enc6@len = byte_size(Enc5@element),
if Enc6@len < 128 ->
[Enc6@len|Enc5@element];
Enc6@len < 16384 ->
[<<2:2,Enc6@len:14>>|Enc5@element];
true ->
encode_fragmented(Enc5@element, 8)
end
end].


dec_Bin(Bytes) ->

%% attribute id(1) with type OCTET STRING
{Term1,Bytes1} = begin
V1@Pad3 = bit_size(Bytes) band 7,
{V1@V0,V1@Buf1} = case Bytes of
<<_:V1@Pad3,0:1,V1@V5:7,V1@V7:V1@V5/binary-unit:8,V1@Buf8/bitstring>> ->
{V1@V7,V1@Buf8};
<<_:V1@Pad3,1:1,0:1,V1@V6:14,V1@V8:V1@V6/binary-unit:8,V1@Buf9/bitstring>> ->
{V1@V8,V1@Buf9};
<<_:V1@Pad3,1:1,1:1,V1@V6:6,V1@Buf7/bitstring>> ->
{V1@V8,V1@Buf9}  = decode_fragmented(V1@V6, V1@Buf7, 8),
{V1@V8,V1@Buf9}
end,
V1@Conv10 = binary:copy(V1@V0),
{V1@Conv10,V1@Buf1}
end,

%% attribute mime(2) with type OCTET STRING
{Term2,Bytes2} = begin
{V2@V0,V2@Buf1} = case Bytes1 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end,
V2@Conv8 = binary:copy(V2@V0),
{V2@Conv8,V2@Buf1}
end,

%% attribute payload(3) with type OCTET STRING
{Term3,Bytes3} = begin
{V3@V0,V3@Buf1} = case Bytes2 of
<<0:1,V3@V3:7,V3@V5:V3@V3/binary-unit:8,V3@Buf6/bitstring>> ->
{V3@V5,V3@Buf6};
<<1:1,0:1,V3@V4:14,V3@V6:V3@V4/binary-unit:8,V3@Buf7/bitstring>> ->
{V3@V6,V3@Buf7};
<<1:1,1:1,V3@V4:6,V3@Buf5/bitstring>> ->
{V3@V6,V3@Buf7}  = decode_fragmented(V3@V4, V3@Buf5, 8),
{V3@V6,V3@Buf7}
end,
V3@Conv8 = binary:copy(V3@V0),
{V3@Conv8,V3@Buf1}
end,
Res1 = {'Bin',Term1,Term2,Term3},
{Res1,Bytes3}.

enc_Typ(Val) ->
if Val =:= new ->
<<0:2>>;
Val =:= edit ->
<<1:2>>;
Val =:= delete ->
<<2:2>>;
true ->
exit({error,{asn1,{illegal_enumerated,Val}}})
end.


dec_Typ(Bytes) ->
begin
<<V1@V0:2/unsigned-unit:1,V1@Buf1/bitstring>> = Bytes,
V1@Int2 = case V1@V0 of
0 -> new;
1 -> edit;
2 -> delete;
_ -> exit({error,{asn1,{decode_enumerated,V1@V0}}})
end,
{V1@Int2,V1@Buf1}
end.

enc_Adr(Val) ->
{ChoiceTag,ChoiceVal} = Val,
if ChoiceTag =:= room ->
[<<0:1>>|enc_MUC(ChoiceVal)];
ChoiceTag =:= chat ->
[<<1:1>>|enc_P2P(ChoiceVal)]
end.


dec_Adr(Bytes) ->
{Choice,Bytes1} = 
begin
<<V1@V0:1/unsigned-unit:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
case Choice of
0 ->
{Val,NewBytes} = begin
dec_MUC(Bytes1)
end,
{{room,Val},NewBytes};
1 ->
{Val,NewBytes} = begin
dec_P2P(Bytes1)
end,
{{chat,Val},NewBytes}
end.
enc_Msg(Val) ->
[align,
begin
%% attribute id(1) with type INTEGER
Enc1@element = element(2, Val),
encode_unconstrained_number(Enc1@element)
end,
begin
%% attribute feed(2) with type Adr
Enc3@element = element(3, Val),
enc_Adr(Enc3@element)
end,
begin
%% attribute files(3) with type SET OF
Enc4@element = element(4, Val),
enc_Msg_files(Enc4@element)
end|begin
%% attribute type(4) with type ENUMERATED
Enc5@element = element(5, Val),
if Enc5@element =:= new ->
<<0:2>>;
Enc5@element =:= edit ->
<<1:2>>;
Enc5@element =:= delete ->
<<2:2>>;
true ->
exit({error,{asn1,{illegal_enumerated,Enc5@element}}})
end
end].
enc_Msg_files(Val) ->
Enc1@len = length(Val),
[if Enc1@len < 128 ->
[align,
Enc1@len];
Enc1@len < 16384 ->
[align|<<2:2,Enc1@len:14>>]
end|[enc_Bin(Comp) || Comp <- Val]].



dec_Msg(Bytes) ->

%% attribute id(1) with type INTEGER
{Term1,Bytes1} = begin
V1@Pad3 = bit_size(Bytes) band 7,
{V1@V0,V1@Buf1} = case Bytes of
<<_:V1@Pad3,0:1,V1@V5:7,V1@Buf6/bitstring>> when V1@V5 =/= 0 ->
{V1@V5,V1@Buf6};
<<_:V1@Pad3,1:1,0:1,V1@V6:14,V1@Buf7/bitstring>> when V1@V6 =/= 0 ->
{V1@V6,V1@Buf7}
end,
<<V1@V8:V1@V0/signed-unit:8,V1@Buf9/bitstring>> = V1@Buf1,
{V1@V8,V1@Buf9}
end,

%% attribute feed(2) with type Adr
{Term2,Bytes2} = dec_Adr(Bytes1),

%% attribute files(3) with type SET OF
{Term3,Bytes3} = dec_Msg_files(Bytes2),

%% attribute type(4) with type ENUMERATED
{Term4,Bytes4} = begin
<<V2@V0:2/unsigned-unit:1,V2@Buf1/bitstring>> = Bytes3,
V2@Int2 = case V2@V0 of
0 -> new;
1 -> edit;
2 -> delete;
_ -> exit({error,{asn1,{decode_enumerated,V2@V0}}})
end,
{V2@Int2,V2@Buf1}
end,
Res1 = {'Msg',Term1,Term2,Term3,Term4},
{Res1,Bytes4}.


dec_Msg_files(Bytes) ->
%% Length with constraint no
V1@Pad3 = bit_size(Bytes) band 7,
{V1@V0,V1@Buf1} = case Bytes of
<<_:V1@Pad3,0:1,V1@V5:7,V1@Buf6/bitstring>> ->
{V1@V5,V1@Buf6};
<<_:V1@Pad3,1:1,0:1,V1@V6:14,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7}
end,
dec_components1(V1@V0, V1@Buf1, []).


%%%
%%% Run-time functions.
%%%

'dialyzer-suppressions'(Arg) ->
    complete(element(1, Arg)),
    ok.

dec_components1(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components1(Num, Bytes, Acc) ->
{Term,Remain} = dec_Bin(Bytes),
dec_components1(Num-1, Remain, [Term|Acc]).

complete(L0) ->
    L = complete(L0, []),
    case list_to_bitstring(L) of
        <<>> ->
            <<0>>;
        Bin ->
            Bin
    end.

complete([], Bits, []) ->
    case Bits band 7 of
        0 ->
            [];
        N ->
            [<<0:(8 - N)>>]
    end;
complete([], Bits, [H|More]) ->
    complete(H, Bits, More);
complete([align|T], Bits, More) ->
    case Bits band 7 of
        0 ->
            complete(T, More);
        1 ->
            [<<0:7>>|complete(T, More)];
        2 ->
            [<<0:6>>|complete(T, More)];
        3 ->
            [<<0:5>>|complete(T, More)];
        4 ->
            [<<0:4>>|complete(T, More)];
        5 ->
            [<<0:3>>|complete(T, More)];
        6 ->
            [<<0:2>>|complete(T, More)];
        7 ->
            [<<0:1>>|complete(T, More)]
    end;
complete([[]|T], Bits, More) ->
    complete(T, Bits, More);
complete([[_|_] = H], Bits, More) ->
    complete(H, Bits, More);
complete([[_|_] = H|T], Bits, More) ->
    complete(H, Bits, [T|More]);
complete([H|T], Bits, More) when is_integer(H); is_binary(H) ->
    [H|complete(T, Bits, More)];
complete([H|T], Bits, More) ->
    [H|complete(T, Bits + bit_size(H), More)];
complete(Bin, Bits, More) when is_binary(Bin) ->
    [Bin|complete([], Bits, More)];
complete(Bin, Bits, More) ->
    [Bin|complete([], Bits + bit_size(Bin), More)].

complete([], []) ->
    [];
complete([], [H|More]) ->
    complete(H, More);
complete([align|T], More) ->
    complete(T, More);
complete([[]|T], More) ->
    complete(T, More);
complete([[_|_] = H], More) ->
    complete(H, More);
complete([[_|_] = H|T], More) ->
    complete(H, [T|More]);
complete([H|T], More) when is_integer(H); is_binary(H) ->
    [H|complete(T, More)];
complete([H|T], More) ->
    [H|complete(T, bit_size(H), More)];
complete(Bin, More) when is_binary(Bin) ->
    [Bin|complete([], More)];
complete(Bin, More) ->
    [Bin|complete([], bit_size(Bin), More)].

decode_fragmented(SegSz0, Buf0, Unit) ->
    SegSz = SegSz0 * Unit * 16384,
    <<Res:SegSz/bitstring,Buf/bitstring>> = Buf0,
    decode_fragmented_1(Buf, Unit, Res).

decode_fragmented_1(<<0:1,N:7,Buf0/bitstring>>, Unit, Res) ->
    Sz = N * Unit,
    <<S:Sz/bitstring,Buf/bitstring>> = Buf0,
    {<<Res/bitstring,S/bitstring>>,Buf};
decode_fragmented_1(<<1:1,0:1,N:14,Buf0/bitstring>>, Unit, Res) ->
    Sz = N * Unit,
    <<S:Sz/bitstring,Buf/bitstring>> = Buf0,
    {<<Res/bitstring,S/bitstring>>,Buf};
decode_fragmented_1(<<1:1,1:1,SegSz0:6,Buf0/bitstring>>, Unit, Res0) ->
    SegSz = SegSz0 * Unit * 16384,
    <<Frag:SegSz/bitstring,Buf/bitstring>> = Buf0,
    Res = <<Res0/bitstring,Frag/bitstring>>,
    decode_fragmented_1(Buf, Unit, Res).

encode_fragmented(Bin, Unit) ->
    encode_fragmented_1(Bin, Unit, 4).

encode_fragmented_1(Bin, Unit, N) ->
    SegSz = Unit * N * 16384,
    case Bin of
        <<B:SegSz/bitstring,T/bitstring>> ->
            [<<3:2,N:6>>,B|encode_fragmented_1(T, Unit, N)];
        _ when N > 1 ->
            encode_fragmented_1(Bin, Unit, N - 1);
        _ ->
            case bit_size(Bin) div Unit of
                Len when Len < 128 ->
                    [Len,Bin];
                Len when Len < 16384 ->
                    [<<2:2,Len:14>>,Bin]
            end
    end.

encode_unconstrained_number(Val) when not is_integer(Val) ->
    exit({error,{asn1,{illegal_integer,Val}}});
encode_unconstrained_number(Val) when Val >= 0 ->
    if
        Val < 128 ->
            [1,Val];
        Val < 256 ->
            [<<2,0>>,Val];
        true ->
            case binary:encode_unsigned(Val) of
                <<0:1,_/bitstring>> = Bin ->
                    case byte_size(Bin) of
                        Sz when Sz < 128 ->
                            [Sz,Bin];
                        Sz when Sz < 16384 ->
                            [<<2:2,Sz:14>>,Bin]
                    end;
                <<1:1,_/bitstring>> = Bin ->
                    case byte_size(Bin) + 1 of
                        Sz when Sz < 128 ->
                            [Sz,0,Bin];
                        Sz when Sz < 16384 ->
                            [<<2:2,Sz:14,0:8>>,Bin]
                    end
            end
    end;
encode_unconstrained_number(Val) ->
    Oct = enint(Val, []),
    Len = length(Oct),
    if
        Len < 128 ->
            [Len|Oct];
        Len < 16384 ->
            [<<2:2,Len:14>>|Oct]
    end.

enint(- 1, [B1|T]) when B1 > 127 ->
    [B1|T];
enint(N, Acc) ->
    enint(N bsr 8, [N band 255|Acc]).
